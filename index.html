<head>
    <link rel='icon' href='#' />
</head>
<body>
    <div style='display: flex; height: 100%; justify-content: center;'><canvas height='400' id='canvas' width='400' /></div>
    <script>
        let arena = {
            acceptedKey: undefined,
            cellSize: 20,
            color: [0, 0, 0],
            desiredKey: undefined,
            msPerFrame: 10,
            onWinOrLost: 1,
            winners: []
        }
        let player = {
            calculatePath: calculateLongestTailChaserPath,
            color: [153, 0, 0],
            exploredPaths: [],
            length: 4,
            path: [],
            positionArray: [{ x: canvas.width / 4, y: canvas.height / 4 }],
            positionHashTable: { [`${canvas.width / 4}, ${canvas.height / 4}`]: 1 }
        }
        let food = {
            color: [153, 255, 255],
            energy: 4
        }

        window.onload = () => {
            canvas = document.getElementById('canvas')
            context = canvas.getContext('2d')
            document.addEventListener('keydown', event => (arena.desiredKey = event.key))
            setInterval(() => {
                context.fillStyle = `rgba(${arena.color[0]}, ${arena.color[1]}, ${arena.color[2]}, 1)`
                context.fillRect(0, 0, canvas.width, canvas.height)

                if (player.positionArray) {
                    player.calculatePath?.(player)
                    let newPosition = player.path.shift()
                    if (newPosition && player.length < player.positionArray.length + 1) {
                        let oldPosition = player.positionArray.pop()
                        delete player.positionHashTable[`${oldPosition.x}, ${oldPosition.y}`]
                    }
                    if (newPosition) {
                        player.positionArray.unshift({ x: newPosition.x, y: newPosition.y })
                        player.positionHashTable[`${newPosition.x}, ${newPosition.y}`] = 1
                    }
                    player.positionArray.forEach((position, i) => {
                        let isLost = (i && position.x === player.positionArray?.[0].x && position.y === player.positionArray?.[0].y) || position.x < 0 || canvas.width <= position.x || position.y < 0 || canvas.height <= position.y
                        let score = player.length / (canvas.height * canvas.width / arena.cellSize / arena.cellSize)
                        if (arena.onWinOrLost === 0 && isLost) {
                            player.positionArray = undefined
                            player.positionHashTable = undefined
                        }
                        if (arena.onWinOrLost === 1 && isLost) {
                            player.calculatePath = undefined
                            player.path = []
                        }
                        if (arena.onWinOrLost === 2 && (isLost || 1 <= score)) {
                            arena.winners.push({ id: player.calculatePath.name, score })
                            console.log(`Iteration: ${arena.winners.length - 1}\nScore: ${score}\nAverage Score: ${arena.winners.reduce((totalScore, winner) => totalScore + winner.score, 0) / arena.winners.length}`)
                            40 <= arena.winners.length && (arena.onWinOrLost = 1)
                            player.length = 4
                            player.path = []
                            player.positionArray = [{ x: canvas.width / 4, y: canvas.height / 4 }]
                            player.positionHashTable = { [`${canvas.width / 4}, ${canvas.height / 4}`]: 1 }
                        }
                        if (position.x === food.position?.x && position.y === food.position?.y) {
                            player.length += food.energy
                            food.position = undefined
                        }
                    })
                    context.fillStyle = `rgba(${player.color[0]}, ${player.color[1]}, ${player.color[2]}, 1)`
                    player.positionArray?.forEach((position, i) => context.fillRect(position.x + Math.min(i, 2), position.y + Math.min(i, 2), arena.cellSize - Math.min(i * 2, 4), arena.cellSize - Math.min(i * 2, 4)))
                    context.fillStyle = `rgba(${player.color[0]}, ${player.color[1]}, ${player.color[2]}, .25)`
                    player.exploredPaths.forEach(position => context.fillRect(Number(position.split(', ')[0]), Number(position.split(', ')[1]), arena.cellSize, arena.cellSize))
                }

                if (!food.position && player.length / (canvas.height * canvas.width / arena.cellSize / arena.cellSize) < 1) {
                    let availablePositions = []
                    for (let y = 0; y < canvas.height; y += arena.cellSize) {
                        for (let x = 0; x < canvas.width; x += arena.cellSize) {
                            if (!player.positionHashTable[`${x}, ${y}`]) {
                                availablePositions.push({ x, y })
                            }
                        }
                    }
                    food.position = availablePositions[Math.floor(Math.random() * availablePositions.length)]
                }
                context.fillStyle = `rgba(${food.color[0]}, ${food.color[1]}, ${food.color[2]}, 1)`
                context.fillRect(food.position?.x, food.position?.y, arena.cellSize, arena.cellSize)
            }, arena.msPerFrame)
        }

        function calculateArrowKeysPath(player) {
            if (arena.desiredKey === 'ArrowUp' && arena.acceptedKey?.id !== 'ArrowDown') {
                arena.acceptedKey = { id: arena.desiredKey, x: 0, y: -arena.pxLen }
            } else if (arena.desiredKey === 'ArrowDown' && arena.acceptedKey?.id !== 'ArrowUp') {
                arena.acceptedKey = { id: arena.desiredKey, x: 0, y: arena.pxLen }
            } else if (arena.desiredKey === 'ArrowLeft' && arena.acceptedKey?.id !== 'ArrowRight') {
                arena.acceptedKey = { id: arena.desiredKey, x: -arena.pxLen, y: 0 }
            } else if (arena.desiredKey === 'ArrowRight' && arena.acceptedKey?.id !== 'ArrowLeft') {
                arena.acceptedKey = { id: arena.desiredKey, x: arena.pxLen, y: 0 }
            }
            if (player.positionArray.length && arena.acceptedKey) {
                player.path.push({ x: player.positionArray[0].x + arena.acceptedKey.x, y: player.positionArray[0].y + arena.acceptedKey.y })
            }
        }

        function calculateCirclePath(player) {
            if (player.path.length) {
                return
            }
            player.path = [
                {
                    x: player.positionArray[0].x + arena.cellSize,
                    y: player.positionArray[0].y
                },
                {
                    x: player.positionArray[0].x + 2 * arena.cellSize,
                    y: player.positionArray[0].y
                },
                {
                    x: player.positionArray[0].x + 2 * arena.cellSize,
                    y: player.positionArray[0].y + arena.cellSize
                },
                {
                    x: player.positionArray[0].x + 2 * arena.cellSize,
                    y: player.positionArray[0].y + 2 * arena.cellSize
                },
                {
                    x: player.positionArray[0].x + arena.cellSize,
                    y: player.positionArray[0].y + 2 * arena.cellSize
                },
                {
                    x: player.positionArray[0].x,
                    y: player.positionArray[0].y + 2 * arena.cellSize
                },
                {
                    x: player.positionArray[0].x,
                    y: player.positionArray[0].y + arena.cellSize
                },
                {
                    x: player.positionArray[0].x,
                    y: player.positionArray[0].y
                }
            ]
            if (player.positionArray[0].x + arena.cellSize === player.positionArray[1]?.x) {
                let position = player.path.pop()
                player.path.reverse().push(position)
            }
        }

        function calculateAStarPath(player) {
            if (!food.position) {
                player.path = []
                return
            }
            if (player.path.length) {
                return
            }
            let vertex = { ...player.positionArray[0], evaluation: Math.sqrt((player.positionArray[0].x - food.position.x) ** 2 + (player.positionArray[0].y - food.position.y) ** 2) }
            let heap = new Heap()
            heap.add(vertex)
            let depths = { [`${vertex.x}, ${vertex.y}`]: 0 }
            let parents = { [`${vertex.x}, ${vertex.y}`]: `${vertex.x}, ${vertex.y}` }

            while (heap.array.length) {
                vertex = heap.remove()

                if (vertex.x === food.position.x && vertex.y === food.position.y) {
                    break
                }

                [
                    { x: vertex.x, y: vertex.y - arena.cellSize },
                    { x: vertex.x, y: vertex.y + arena.cellSize },
                    { x: vertex.x - arena.cellSize, y: vertex.y },
                    { x: vertex.x + arena.cellSize, y: vertex.y }
                ]
                    .filter(neighbor => !player.positionArray.slice(0, Math.max(0, player.length - 1 - depths[`${vertex.x}, ${vertex.y}`])).find(position => position.x === neighbor.x && position.y === neighbor.y) && 0 <= neighbor.x && neighbor.x < canvas.width && 0 <= neighbor.y && neighbor.y < canvas.height && !parents[`${neighbor.x}, ${neighbor.y}`])
                    .map(neighbor => ({ ...neighbor, evaluation: Math.sqrt((neighbor.x - food.position.x) ** 2 + (neighbor.y - food.position.y) ** 2) }))
                    .forEach(neighbor => {
                        heap.add(neighbor)
                        depths[`${neighbor.x}, ${neighbor.y}`] = depths[`${vertex.x}, ${vertex.y}`] + 1
                        parents[`${neighbor.x}, ${neighbor.y}`] = `${vertex.x}, ${vertex.y}`
                    })
            }
            path = []
            vertex = `${food.position.x}, ${food.position.y}`
            while (parents[vertex] !== vertex) {
                path.push({ x: Number(vertex.split(', ')[0]), y: Number(vertex.split(', ')[1]) })
                vertex = parents[vertex]
            }

            if (vertex === `${player.positionArray[0].x}, ${player.positionArray[0].y}`) {
                player.path = path.reverse()
            } else {
                calculateCirclePath(player)
            }
            player.exploredPaths = Object.keys(parents)
        }

        let _iter
        function calculateLongestTailChaserPath(player) {
            if (player.path.length) {
                return
            }
            let seen = {}
            _iter = 0
            cltcpHelper(player, [player.positionArray[0]], { [`${player.positionArray[0].x}, ${player.positionArray[0].y}`]: 1 }, seen)
            if (!player.path.length) {
                calculateAStarPath(player)
            }
        }

        function cltcpHelper(player, pathArray, pathHashTable, seen) {
            _iter += 1
            let vertex = pathArray[pathArray.length - 1]

            if (player.path.length || 32768 <= _iter) {
                return
            }
            if (Math.sqrt((vertex.x - player.positionArray[player.positionArray.length - 1].x) ** 2 + (vertex.y - player.positionArray[player.positionArray.length - 1].y) ** 2) === arena.cellSize) {
                player.path = pathArray.slice(1)
                player.exploredPaths = Object.keys(seen)
                return
            }

            [
                { x: vertex.x, y: vertex.y - arena.cellSize },
                { x: vertex.x, y: vertex.y + arena.cellSize },
                { x: vertex.x - arena.cellSize, y: vertex.y },
                { x: vertex.x + arena.cellSize, y: vertex.y }
            ]
                .filter(neighbor => !player.positionHashTable[`${neighbor.x}, ${neighbor.y}`] && 0 <= neighbor.x && neighbor.x < canvas.width && 0 <= neighbor.y && neighbor.y < canvas.height && !pathHashTable[`${neighbor.x}, ${neighbor.y}`])
                .map(neighbor => ({ ...neighbor, evaluation: Math.sqrt((neighbor.x - player.positionArray[player.positionArray.length - 1].x) ** 2 + (neighbor.y - player.positionArray[player.positionArray.length - 1].y) ** 2) }))
                .sort((a, b) => a.evaluation < b.evaluation ? 1 : -1)
                .forEach(neighbor => {
                    pathArray.push(neighbor)
                    pathHashTable[`${neighbor.x}, ${neighbor.y}`] = 1
                    seen[`${neighbor.x}, ${neighbor.y}`] = 1
                    cltcpHelper(player, pathArray, pathHashTable, seen)
                    pathArray.pop()
                    delete pathHashTable[`${neighbor.x}, ${neighbor.y}`]
                })
        }

        let _cache
        function calculateHamiltonianCyclePath(player) {
            if (player.path.length) {
                return
            }
            if (_cache) {
                player.path = _cache.slice()
                return
            }
            let vertex = {
                x: Math.floor(Math.random() * canvas.height / arena.cellSize) * arena.cellSize,
                y: Math.floor(Math.random() * canvas.height / arena.cellSize) * arena.cellSize
            }
            _iter = 0
            chcpHelper(player, [vertex], { [`${vertex.x}, ${vertex.y}`]: 1 })
        }

        function chcpHelper(player, pathArray, pathHashTable) {
            _iter += 1
            let vertex = pathArray[pathArray.length - 1]

            if (_cache || 32768 <= _iter) {
                return
            }
            if (pathArray.length === (canvas.height * canvas.width / arena.cellSize / arena.cellSize)) {
                _cache = pathArray.slice()
                return
            }

            [
                { x: vertex.x, y: vertex.y - arena.cellSize },
                { x: vertex.x, y: vertex.y + arena.cellSize },
                { x: vertex.x - arena.cellSize, y: vertex.y },
                { x: vertex.x + arena.cellSize, y: vertex.y }
            ]
                .filter(neighbor => 0 <= neighbor.x && neighbor.x < canvas.width && 0 <= neighbor.y && neighbor.y < canvas.height && !pathHashTable[`${neighbor.x}, ${neighbor.y}`])
                .map(neighbor => ({ ...neighbor, evaluation: Math.sqrt((neighbor.x - pathArray[0].x) ** 2 + (neighbor.y - pathArray[0].y) ** 2) }))
                .sort((a, b) => a.evaluation < b.evaluation ? 1 : -1)
                .forEach(neighbor => {
                    pathArray.push(neighbor)
                    pathHashTable[`${neighbor.x}, ${neighbor.y}`] = 1
                    chcpHelper(player, pathArray, pathHashTable)
                    pathArray.pop()
                    delete pathHashTable[`${neighbor.x}, ${neighbor.y}`]
                })
        }

        class Heap {
            constructor() {
                this.array = []
            }
            getParentIndex(i) {
                return Math.floor((i - 1) / 2)
            }
            getLeftChildIndex(i) {
                return 2 * i + 1
            }
            getRightChildIndex(i) {
                return 2 * i + 2
            }
            add(item) {
                this.array.push(item)
                let i = this.array.length - 1
                while (0 <= this.getParentIndex(i) && this.array[i].evaluation < this.array[this.getParentIndex(i)].evaluation) {
                    let temp = this.array[this.getParentIndex(i)]
                    this.array[this.getParentIndex(i)] = this.array[i]
                    this.array[i] = temp
                    i = this.getParentIndex(i)
                }
            }
            remove() {
                if (this.array.length === 0) {
                    return
                }
                let item = this.array[0]
                this.array[0] = this.array[this.array.length - 1]
                this.array.pop()
                let i = 0
                while (this.getLeftChildIndex(i) < this.array.length) {
                    let minChildIndex = this.getLeftChildIndex(i)
                    if (this.getRightChildIndex(i) < this.array.length && this.array[this.getRightChildIndex(i)].evaluation < this.array[this.getLeftChildIndex(i)].evaluation) {
                        minChildIndex = this.getRightChildIndex(i)
                    }

                    if (this.array[i] < this.array[minChildIndex]) {
                        break
                    } else {
                        let temp = this.array[i]
                        this.array[i] = this.array[minChildIndex]
                        this.array[minChildIndex] = temp
                    }
                    i = minChildIndex
                }
                return item
            }
        }
    </script>
</body>
<!-- <head>
    <link rel='icon' href='#' />
</head>
<body>
    <div style='display: flex; height: 100%; justify-content: center;'><canvas height='400' id='canvas' width='400' /></div>
    <script>
        // Average Score: 0.5787096774193549
        let arena = {
            acceptedKey: undefined,
            color: [0, 0, 0],
            desiredKey: undefined,
            pxLen: 20,
            time: 0,
            winners: []
        }
        let player0 = {
            calcPath: calcLongestPathToTail,
            color: [153, 0, 0],
            length: 4,
            path: [],
            pos: [{ x: canvas.width / 4, y: canvas.height / 4 }],
            posHashTable: { [`${canvas.width / 4}, ${canvas.height / 4}`]: 1 },
            seen: [],
            target: undefined
        }
        let player1 = {
            calcPath: undefined,
            color: [255, 153, 51],
            length: 4,
            path: [],
            // pos: [{ x: canvas.width * 3 / 4, y: canvas.height / 4 }],
            posHashTable: { [`${canvas.width * 3 / 4}, ${canvas.height / 4}`]: 1 },
            seen: [],
            target: undefined
        }
        let player2 = {
            calcPath: undefined,
            color: [255, 255, 204],
            length: 4,
            path: [],
            // pos: [{ x: canvas.width / 4, y: canvas.height * 3 / 4 }],
            posHashTable: { [`${canvas.width / 4}, ${canvas.height * 3 / 4}`]: 1 },
            seen: [],
            target: undefined
        }
        let player3 = {
            calcPath: undefined,
            color: [153, 255, 153],
            length: 4,
            path: [],
            // pos: [{ x: canvas.width * 3 / 4, y: canvas.height * 3 / 4 }],
            posHashTable: { [`${canvas.width * 3 / 4}, ${canvas.height * 3 / 4}`]: 1 },
            seen: [],
            target: undefined
        }
        let food = {
            color: [153, 255, 255],
            energy: 4
        }
        let walls = undefined
        let portals = undefined

        window.onload = () => {
            canvas = document.getElementById('canvas')
            context = canvas.getContext('2d')
            document.addEventListener('keydown', event => (arena.desiredKey = event.key))
            setInterval(() => {
                context.fillStyle = `rgba(${arena.color[0]}, ${arena.color[1]}, ${arena.color[2]}, 1)`
                context.fillRect(0, 0, canvas.width, canvas.height)

                new Array(player0, player1, player2, player3).filter(player => player.pos?.length).forEach(player => {
                    context.fillStyle = `rgba(${player.color[0]}, ${player.color[1]}, ${player.color[2]}, 1)`
                    player.pos.forEach((pos, i) => context.fillRect(pos.x + Math.min(i, 2), pos.y + Math.min(i, 2), arena.pxLen - Math.min(i * 2, 4), arena.pxLen - Math.min(i * 2, 4)))
                    if (player.target && (player.target.x !== food.pos?.x || player.target.y !== food.pos?.y)) {
                        player.path = []
                        player.target = undefined
                    }
                    food.pos && player.calcPath?.(player)
                    let pos = player.path.shift()
                    if (pos) {
                        player.pos.unshift({ x: pos.x, y: pos.y })
                        player.posHashTable[`${pos.x}, ${pos.y}`] = 1
                    }
                    while (player.length < player.pos.length) {
                        pos = player.pos.pop()
                        player.posHashTable[`${pos.x}, ${pos.y}`] = undefined
                    }
                    player.pos.forEach((pos, i) => {
                        let didPlayerUnaliveThemselves = pos.x < 0 || canvas.width <= pos.x || pos.y < 0 || canvas.height <= pos.y || (i && pos.x === player.pos?.[0].x && pos.y === player.pos?.[0].y)
                        let shouldPlayerDespawn = 1 < [player0, player1, player2, player3].filter(player => player.pos).length
                        let score = player.length / (canvas.height * canvas.width / arena.pxLen / arena.pxLen)
                        if (didPlayerUnaliveThemselves && shouldPlayerDespawn) {
                            player.pos = undefined
                            player.posHashTable = undefined
                        }
                        if (didPlayerUnaliveThemselves && !shouldPlayerDespawn || 1 <= score) {
                            arena.winners.push({ id: player.calcPath.name, score })
                            console.log(`Iteration: ${arena.winners.length - 1}\nScore: ${score}\nAverage Score: ${arena.winners.reduce((totalScore, winner) => totalScore + winner.score, 0) / arena.winners.length}`)
                            player.length = 4
                            player.path = []
                            player.pos = [{ x: canvas.width / 4, y: canvas.height / 4 }]
                            player.posHashTable = { [`${canvas.width / 4}, ${canvas.height / 4}`]: 1 }
                            player.target = undefined
                        }
                        if (pos.x === food.pos?.x && pos.y === food.pos?.y) {
                            player.length += food.energy
                            food.pos = undefined
                        }
                    })
                    context.fillStyle = `rgba(${player.color[0]}, ${player.color[1]}, ${player.color[2]}, .25)`
                    player.seen.forEach(pos => context.fillRect(Number(pos.split(', ')[0]), Number(pos.split(', ')[1]), arena.pxLen, arena.pxLen))
                })

                context.fillStyle = `rgba(${food.color[0]}, ${food.color[1]}, ${food.color[2]}, 1)`
                context.fillRect(food.pos?.x, food.pos?.y, arena.pxLen, arena.pxLen)
                if (!food.pos) {
                    food.pos = {
                        x: Math.floor(Math.random() * canvas.width / arena.pxLen) * arena.pxLen,
                        y: Math.floor(Math.random() * canvas.height / arena.pxLen) * arena.pxLen
                    }
                }
            }, arena.time)
        }

        function calcControllerPath(player) {
            if (arena.desiredKey === 'ArrowUp' && arena.acceptedKey?.id !== 'ArrowDown') {
                arena.acceptedKey = { id: arena.desiredKey, x: 0, y: -arena.pxLen }
            } else if (arena.desiredKey === 'ArrowDown' && arena.acceptedKey?.id !== 'ArrowUp') {
                arena.acceptedKey = { id: arena.desiredKey, x: 0, y: arena.pxLen }
            } else if (arena.desiredKey === 'ArrowLeft' && arena.acceptedKey?.id !== 'ArrowRight') {
                arena.acceptedKey = { id: arena.desiredKey, x: -arena.pxLen, y: 0 }
            } else if (arena.desiredKey === 'ArrowRight' && arena.acceptedKey?.id !== 'ArrowLeft') {
                arena.acceptedKey = { id: arena.desiredKey, x: arena.pxLen, y: 0 }
            }
            if (player.pos.length && arena.acceptedKey) {
                player.path.push({ x: player.pos[0].x + arena.acceptedKey.x, y: player.pos[0].y + arena.acceptedKey.y })
            }
        }

        function calcLoopPath(player) {
            if (player.path.length) return
            player.path = player.path.concat([
                {
                    x: player.pos[0].x + arena.pxLen,
                    y: player.pos[0].y
                },
                {
                    x: player.pos[0].x + 2 * arena.pxLen,
                    y: player.pos[0].y
                },
                {
                    x: player.pos[0].x + 2 * arena.pxLen,
                    y: player.pos[0].y + arena.pxLen
                },
                {
                    x: player.pos[0].x + 2 * arena.pxLen,
                    y: player.pos[0].y + 2 * arena.pxLen
                },
                {
                    x: player.pos[0].x + arena.pxLen,
                    y: player.pos[0].y + 2 * arena.pxLen
                },
                {
                    x: player.pos[0].x,
                    y: player.pos[0].y + 2 * arena.pxLen
                },
                {
                    x: player.pos[0].x,
                    y: player.pos[0].y + arena.pxLen
                },
                {
                    x: player.pos[0].x,
                    y: player.pos[0].y
                }
            ])
        }

        function calcAStarPath(player) {
            if (player.path.length || player.posHashTable[`${food.x}, ${food.y}`]) return
            let vertex = { ...player.pos[0], eval: Math.sqrt((player.pos[0].x - food.pos.x) ** 2 + (player.pos[0].y - food.pos.y) ** 2) }
            let deque = [vertex]
            let parents = { [`${vertex.x}, ${vertex.y}`]: `${vertex.x}, ${vertex.y}` }
            let depths = { [`${vertex.x}, ${vertex.y}`]: 0 }
            let _iter = 0

            while (deque.length && _iter < 2048) {
                let bestEval = Number.MAX_VALUE
                let bestEvalIndex = undefined
                deque.forEach((vertex, i) => {
                    if (vertex.eval < bestEval) {
                        bestEval = vertex.eval
                        bestEvalIndex = i
                    }
                })
                vertex = deque.splice(bestEvalIndex, 1)[0]
                if (vertex.x === food.pos.x && vertex.y === food.pos.y) {
                    break
                }
                let neighbors = [
                    { x: vertex.x, y: vertex.y - arena.pxLen },
                    { x: vertex.x, y: vertex.y + arena.pxLen },
                    { x: vertex.x - arena.pxLen, y: vertex.y },
                    { x: vertex.x + arena.pxLen, y: vertex.y }
                ]
                playerPos = 0 < depths[`${vertex.x}, ${vertex.y}`] - (player.length - player.pos.length) ? player.pos.slice(0, -(depths[`${vertex.x}, ${vertex.y}`] - (player.length - player.pos.length))) : player.pos
                neighbors
                    .filter(neighbor => 0 <= neighbor.x && neighbor.x < canvas.width && 0 <= neighbor.y && neighbor.y < canvas.height && !playerPos.find(pos => pos.x === neighbor.x && pos.y === neighbor.y))
                    .map(neighbor => ({ ...neighbor, eval: Math.sqrt((neighbor.x - food.pos.x) ** 2 + (neighbor.y - food.pos.y) ** 2) }))
                    .forEach(neighbor => {
                        if (!parents[`${neighbor.x}, ${neighbor.y}`]) {
                            deque.push(neighbor)
                            parents[`${neighbor.x}, ${neighbor.y}`] = `${vertex.x}, ${vertex.y}`
                            depths[`${neighbor.x}, ${neighbor.y}`] = depths[`${vertex.x}, ${vertex.y}`] + 1
                        }
                    })
                _iter += 1
            }

            path = []
            vertex = `${food.pos.x}, ${food.pos.y}`
            while (vertex) {
                path.unshift({ x: Number(vertex.split(', ')[0]), y: Number(vertex.split(', ')[1]) })
                if (parents[vertex] === vertex) {
                    break
                }
                vertex = parents[vertex]
            }
            if (path[0].x === player.pos[0].x && path[0].y === player.pos[0].y) {
                player.path = path.slice(1)
                player.target = food.pos
            } else {
                calcLoopPath(player)
            }
            player.seen = Object.keys(parents)
        }

        let calcLongestPathToFoodHelper = {
            _iter: 0,
            recursiveDFS: (player, path) => {
                calcLongestPathToFoodHelper._iter += 1
                let vertex = path[path.length - 1]
                if (player.path.length || 16384 <= calcLongestPathToFoodHelper._iter) {
                    return
                }
                if (vertex.x === food.pos.x && vertex.y === food.pos.y) {
                    if (.8 <= calcLongestPathToFoodHelper.getPositionsReachableAtDestination(player, path.slice(path.length - player.length - food.energy))) {
                        player.path = path.slice(1)
                        player.target = food.pos
                    }
                    return
                }
                [
                    { x: vertex.x, y: vertex.y - arena.pxLen },
                    { x: vertex.x, y: vertex.y + arena.pxLen },
                    { x: vertex.x - arena.pxLen, y: vertex.y },
                    { x: vertex.x + arena.pxLen, y: vertex.y }
                ]
                    .filter(neighbor => 0 <= neighbor.x && neighbor.x < canvas.width && 0 <= neighbor.y && neighbor.y < canvas.height && !player.posHashTable[`${neighbor.x}, ${neighbor.y}`])
                    .map(neighbor => ({ ...neighbor, eval: Math.sqrt((neighbor.x - food.pos.x) ** 2 + (neighbor.y - food.pos.y) ** 2) }))
                    .sort((a, b) => a.eval < b.eval ? 1 : -1)
                    .forEach(neighbor => {
                        if (!path.find(pos => pos.x === neighbor.x && pos.y === neighbor.y)) {
                            path.push(neighbor)
                            calcLongestPathToFoodHelper.recursiveDFS(player, path)
                            path.pop()
                        }
                    })
            },
            getPositionsReachableAtDestination: (player, path) => {
                let pathHashTable = path.reduce((pathHashTable, pos) => { pathHashTable[`${pos.x}, ${pos.y}`] = 1; return pathHashTable; }, {})
                let deque = [path[path.length - 1]]
                let seen = {}
                let _iter = 0
                while (deque.length && _iter < 2048) {
                    let vertex = deque.pop()
                    seen[`${vertex.x}, ${vertex.y}`] = 1;
                    [
                        { x: vertex.x, y: vertex.y - arena.pxLen },
                        { x: vertex.x, y: vertex.y + arena.pxLen },
                        { x: vertex.x - arena.pxLen, y: vertex.y },
                        { x: vertex.x + arena.pxLen, y: vertex.y }
                    ].filter(neighbor => 0 <= neighbor.x && neighbor.x < canvas.width && 0 <= neighbor.y && neighbor.y < canvas.height && !pathHashTable[`${neighbor.x}, ${neighbor.y}`]).forEach(neighbor => {
                        if (!seen[`${neighbor.x}, ${neighbor.y}`]) {
                            deque.push(neighbor)
                        }
                    })
                    _iter += 1
                }
                return .8 <= (Object.keys(seen).length - 1) / (canvas.height * canvas.width / arena.pxLen / arena.pxLen - player.length - food.energy)
            }
        }

        function calcLongestPathToFood(player) {
            if (player.path.length) return
            calcLongestPathToFoodHelper._iter = 0
            calcLongestPathToFoodHelper.recursiveDFS(player, [player.pos[0]])
            if (player.path.length === 0) {
                calcLongestPathToTail(player)
            }
        }

        let calcLongestPathToTailHelper = {
            _iter: 0,
            recursiveDFS: (player, path) => {
                calcLongestPathToTailHelper._iter += 1
                let vertex = path[path.length - 1]
                if (player.path.length || 16384 <= calcLongestPathToTailHelper._iter) {
                    return
                }
                if (Math.sqrt((vertex.x - player.pos[player.pos.length - 1].x) ** 2 + (vertex.y - player.pos[player.pos.length - 1].y) ** 2) === arena.pxLen) {
                    player.path = path.slice(1)
                    return
                }
                [
                    { x: vertex.x, y: vertex.y - arena.pxLen },
                    { x: vertex.x, y: vertex.y + arena.pxLen },
                    { x: vertex.x - arena.pxLen, y: vertex.y },
                    { x: vertex.x + arena.pxLen, y: vertex.y }
                ]
                    .filter(neighbor => 0 <= neighbor.x && neighbor.x < canvas.width && 0 <= neighbor.y && neighbor.y < canvas.height && !player.posHashTable[`${neighbor.x}, ${neighbor.y}`])
                    .map(neighbor => ({ ...neighbor, eval: Math.sqrt((neighbor.x - player.pos[player.pos.length - 1].x) ** 2 + (neighbor.y - player.pos[player.pos.length - 1].y) ** 2) }))
                    .sort((a, b) => a.eval < b.eval ? 1 : -1)
                    .forEach(neighbor => {
                        if (!path.find(pos => pos.x === neighbor.x && pos.y === neighbor.y)) {
                            path.push(neighbor)
                            calcLongestPathToTailHelper.recursiveDFS(player, path)
                            path.pop()
                        }
                    })
            }
        }

        function calcLongestPathToTail(player) {
            if (player.path.length) return
            calcLongestPathToTailHelper._iter = 0
            calcLongestPathToTailHelper.recursiveDFS(player, [player.pos[0]])
            if (player.path.length === 0) {
                calcAStarPath(player)
            }
        }
    </script>
</body> -->
